## 最佳买卖股票时机含冷冻期

[309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

#### 解题思路：动态规划

动态规划三步：

1. 定义状态转移方程
2. 给定方程初始值
3. 递推实现

定义`dp`数组：

- `dp[i][0] `: 第`i`天结束之后，持有股票时，手里持有的最大利润；因为手里持有股票，还没有卖，所以一定不在冷冻期，也就不区分持有股票在冷冻期或持有股票不在冷冻期
- `dp[i][1] `: 第`i`天结束之后，不持有股票时，且在冷冻期时，手里持有的最大利润
- `dp[i][2] `: 第`i`天结束之后，不持有股票时，且不在冷冻期时，手里持有的最大利润



对于第`i`天结束之后持有股票时，有两种情况：

1. 第`i - 1`天结束之后,也持有股票，第`i`天什么也不做
2. 第`i - 1`天结束之后不持有股票，且不在冷冻期，在第`i`天买入股票，花费金额`price[i]`

所以对于`dp[i][0]` 的状态转移方程为：

```java
dp[i][0] = max(dp[i - 1][0],dp[i - 1][2] - prices[i])
```



对于第`i`天结束之后不持有股票，且在冷冻期时,只有一种情况：

1. 第`i - 1`天持有股票并在第`i`天卖出

所以对于`dp[i][1]` 的状态转移方程为：

```java
dp[i][1] = dp[i - 1][0] + prices[i]
```



对于第`i`天结束之后不持有股票，且不在冷冻期时，有两种情况：

1. 第`i - 1`天结束之后 也不持有股票，且不在冷冻期
2. 第`i - 1`天结束之后 为冷冻期

所以对于`dp[i][2]` 的状态转移方程为:

```java
dp[i][2] = max(dp[i - 1][2],dp[i - 1][1])
```



返回结果：

最后返回的结果一定为手中没有股票的情况，即：

```java
return max(dp[prices.length - 1][1],dp[prices.length - 1][2])
```



#### 代码

*Java*

```java
class Solution {
    public int maxProfit(int[] prices) {
        // dp[i][0] : 第i天结束之后，持有股票时，手里持有的最大利润；因为手里持有股票，还没有卖，所以一定不在冷冻期
        // dp[i][1] : 第i天结束之后，不持有股票时，且在冷冻期时，手里持有的最大利润
        // dp[i][2] : 第i天结束之后，不持有股票时，且不在冷冻期时，手里持有的最大利润

        // 第i天结束之后持有股票时，有两种情况：
        // 第i - 1天也持有股票，第i天什么也不做
        // 第i - 1天不持有股票，且不在冷冻期，在第i天买入股票，花费金额price[i]
        // dp[i][0] = max(dp[i - 1][0],dp[i - 1][2] - prices[i])
         

        // 第i天结束之后不持有股票，且在冷冻期时，只有一种情况，就是第i - 1天持有股票并在第i天卖出
        // dp[i][1] = dp[i - 1][0] + prices[i]

        // 第i天结束之后不持有股票，且不在冷冻期时，有两种情况：
        // 第i - 1天 也不持有股票，且不在冷冻期
        // 第i - 1天 为冷冻期
        // dp[i][2] = max(dp[i - 1][2],dp[i - 1][1])

        // 最后返回的结果值一定为手中没有股票的情况
        if(prices == null || prices.length == 0){
            return 0;
        }
        int[][] dp = new int[prices.length][3];
        // 初始化dp
        dp[0][0] = 0 - prices[0];
        dp[0][1] = 0;  
        dp[0][2] = 0;

        for(int i = 1; i < prices.length; i++){
            dp[i][0] = Math.max(dp[i - 1][0],dp[i - 1][2] - prices[i]);
            dp[i][1] = dp[i - 1][0] + prices[i];
            dp[i][2] = Math.max(dp[i - 1][2],dp[i - 1][1]);
        }
        return Math.max(dp[prices.length - 1][1],dp[prices.length - 1][2]);

    }
}
```

